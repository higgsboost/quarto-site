{
  "hash": "5f996676885ecc6e87c755f218856911",
  "result": {
    "markdown": "---\ntitle: Computation neural science\nformat: html\nreference-location: margin\nbibliography: ../../references.bib\nhtml-math-method: katex\neditor:\n  render-on-save: true\nexecute:\n  freeze: true\n---\n\n## Tutorials from @miller_introductory_2018\n\n### Tutorial 2.1\n\n**1a** Code LIF neuron using the equation\n\n$$C_m \\frac{dV_m}{dt} = (E_L - V_m)/R_m + I_{app}   $$\n\n\nwith the condition $\\quad V_m > V_{th}$ then $V_m \\rightarrow V_{reset}$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nimport numpy as np\n\n\nC_m = 2.e-9\nE_L = -70.e-3\nE_K = -80e-3\nR_m = 5.e6\nG_L = 1./R_m\nV_th = -50.e-3\nV_reset = -65.e-3\n\ntau_m = C_m/G_L\n\ndt = 0.1e-3\n\ntimes = np.arange(0, 200.e-3, dt)\nV = np.zeros_like(times)\n\nI_th = G_L*(V_th - E_L)\nI = np.ones_like(times) * I_th \n\nV[0] = E_L\n\ndef dvdt(V_m, I_app, G_ref=None):\n    value = (E_L - V_m)/R_m + I_app \n    if G_ref is not None:\n        value = value + G_ref* (E_K- V_m)\n    value = value/C_m\n    return value\n\n\ndef simulate(V, I, noises=None, tau_ref=None, tau_vth=None, V_th_array=None, G_ref=None, tau_Gref=None):\n    num_fire = 0\n    last_fire_time = -100\n\n    dvthdt_array = []\n    for i in range(1, len(times)):\n        if G_ref is None:\n            V_new = V[i-1] + dvdt(V[i-1], I[i-1]) * dt\n        else:\n            V_new = V[i-1] + dvdt(V[i-1], I[i-1], G_ref[i-1]) * dt\n                \n        if tau_vth is not None:\n            dvthdt = (-50e-3 - V_th_array[i-i]) / tau_vth\n            dvthdt_array.append(V_th_array[i-i])\n            V_th_array[i] = V_th_array[i-1] + dt*dvthdt\n        \n        if G_ref is not None:            \n            dG_refdt = -G_ref[i-1]/tau_Gref\n            G_ref[i] = G_ref[i-1] + dt * dG_refdt\n        if tau_vth is not None:\n            \n            if V_new > V_th_array[i-1]:  # Fire\n                V_new = V_reset\n                num_fire += 1\n                \n                V_th_array[i-1] = 200e-3\n                \n                if G_ref is not None: \n                    \n                    G_ref[i] =G_ref[i]+ 2e-6\n                                   \n        else:\n            if V_new > V_th: \n                V_new = V_reset\n                num_fire += 1\n                last_fire_time = times[i]\n        \n        if noises is not None:\n            V_new += noises[i]\n        \n        if tau_ref is not None:\n            if times[i] - last_fire_time < tau_ref:\n                V_new = V_reset\n        \n        V[i] = V_new\n    \n    fire_rate = num_fire/(times[-1] - times[0])\n    \n    if tau_vth is not None:\n        return fire_rate, dvthdt_array\n    return fire_rate\n```\n:::\n\n\n**1b** What is the minimum required applied current for a spike?\n\nThe equation for the current threshold is\n$$I_{th} = G_L(V_{th} - E_L)$$\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nI_th = G_L * (V_th - E_L)\nprint(f'I_th : {I_th}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI_th : 4e-09\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nimport matplotlib.pyplot as plt\n\nV_1 = np.copy(V)\nV_2 = np.copy(V)\nsimulate(V_1, np.ones_like(V_1) * I_th*.99)\nsimulate(V_2, np.ones_like(V_1) * I_th*1.01)\n\nplt.figure()\nplt.plot(times, V_1)\nplt.xlabel('Time (s) ')\nplt.ylabel('Voltage (V) ')\nplt.title('Applied current is : $0.99 * I_{th}$ ')\n\nplt.figure()\nplt.plot(times, V_2)\nplt.xlabel('Time (s) ')\nplt.ylabel('Voltage (V) ')\nplt.title('Applied current is : $1.01 * I_{th}$ ')\n\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nText(0.5, 1.0, 'Applied current is : $1.01 * I_{th}$ ')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-4-output-2.png){width=625 height=443}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-4-output-3.png){width=625 height=443}\n:::\n:::\n\n\nBy plotting the voltage vs time plots the equation for the current threshold is validated; we can see that for slightly (1%) below the threshold current $I_{th}$ no spikes are generated, but when increased to higher than the threshold current, many spikes can be seen.\n\n**1c&d** Change $I_{app}$ and measure the average firing rate ($f$) varies in the range from $0$ to $100Hz$, and then verify the equation.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nfr_array = []\nfr_eq_array = []    \ndef fr_func(I):\n    value = tau_m * np.log(max(0.00001, I * R_m + E_L - V_reset)) - tau_m * np.log(max(0.000001, I*R_m + E_L-V_th))\n    value = 1./value\n    return value\n\n\nfor I in np.arange(4e-10, 1e-8, 1e-9):\n    V_3 = np.copy(V)\n    fr = simulate(V_3, np.ones_like(times) * I)\n    fr_array.append(fr)\n    fr_eq = fr_func(I)\n    fr_eq_array.append(fr_eq)\nfig = plt.figure()\n\nplt.plot(np.arange(4e-10, 1e-8, 1e-9),fr_array)\n\n\nplt.plot(np.arange(4e-10, 1e-8, 1e-9),fr_eq_array)\n\nplt.xlabel('Applied current $I_{app}$')\nplt.ylabel('Firing rate $f(hz)$') \n_=plt.title('$I_{app}$ vs firing rate $f$')\n```\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-5-output-1.png){width=595 height=446}\n:::\n:::\n\n\nAdd a noise term for each time step.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nV_4 = np.copy(V)\n\nnoises_fn = lambda sigma_I:  np.random.normal(size=times.shape) * sigma_I * np.sqrt(dt)\n\nplt.figure()\nfor sigma_I in range(0, 5,):\n    fr_array = []\n    for I in np.arange(4e-10, 1e-8, 1e-9):\n        V_4 = np.copy(V)\n        fr = simulate(V_4, np.ones_like(times) * I, noises_fn(sigma_I))\n        fr_array.append(fr)\n    \n        \n\n    plt.plot(np.arange(4e-10, 1e-8, 1e-9), fr_array)\n```\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-6-output-1.png){width=575 height=421}\n:::\n:::\n\n\nLooks like as `sigma_I` increases the f-r curve slope is decreased, also the curve is less smooth.\n\n\n## Tutorial 2.2\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nC_m = 0.1e-9\nE_L = -70.e-3\nR_m = 100.e6\nG_L = 1./R_m\nV_th = -50e-3\nV_reset = -65.e-3\n\ntau_m = C_m/G_L\nI_th = G_L*(V_th - E_L)\n\nfr_array_1 = [] # Forced voltage clamp method\nmean_V_1 = []\n\nfr_array_2 = [] # Threshold increase\nmean_V_2 = []\n\nfr_array_3 = [] # Threshold increase\nmean_V_3 = []\nI_array = np.arange(100e-12, 600e-12, 50e-12)\n\nfor I in I_array:\n    V_1 = np.copy(V)\n    fr_1 = simulate(V_1, np.ones_like(times) * I, tau_ref=2.5e-3)\n    fr_array_1.append(fr_1)\n    mean_V_1.append(np.mean(V_1))\n    \n    V_2 = np.copy(V)\n    V_th_array = np.zeros_like(times)\n    V_th_array[0] = V_th\n    fr_2,dvthdt_array = simulate(V_2, np.ones_like(times) * I, tau_vth=1e-3, V_th_array=V_th_array)\n    fr_array_2.append(fr_2)\n    mean_V_2.append(np.mean(V_2))\n    \n    \n    V_3 = np.copy(V)\n    V_th_array = np.zeros_like(times)\n    G_ref = np.zeros_like(times)\n    V_th_array[0] = V_th\n    G_ref[0] = 0.\n    fr_3,_ = simulate(V_3, np.ones_like(times) * I, tau_vth=1e-3, V_th_array=V_th_array, G_ref=G_ref, tau_Gref=0.2e-3)\n    print(fr_3)\n    fr_array_3.append(fr_3)\n    mean_V_3.append(np.mean(V_3))\nfig = plt.figure().suptitle('current vs fr')\n\nplt.plot(I_array, fr_array_1, label='forced voltage clamp')\nplt.plot(I_array, fr_array_2, label='threshold increase')\nplt.plot(I_array, fr_array_3, label='refractory conductance')\nplt.xlabel('I')\nplt.ylabel('fr')\nplt.legend(loc='lower right')\nplt.figure().suptitle('current vs mean V')\nplt.plot(I_array, mean_V_1,  label='forced voltage clamp')\nplt.plot(I_array, mean_V_2, label='threshold increase')\nplt.plot(I_array, mean_V_3, label='refractory')\nplt.xlabel('I')\nplt.ylabel('Mean V')\nplt.legend(loc='lower right')\nplt.figure().suptitle('  fr vs mean V')\nplt.plot( fr_array_1,mean_V_1, label='forced voltage clamp')\nplt.plot( fr_array_2,mean_V_2,label='threshold increase')\nplt.plot( fr_array_3,mean_V_3,label='refractory')\nplt.xlabel('fr')\nplt.ylabel('Mean V')\nplt.legend(loc='lower right')\n\nplt.figure().suptitle('  V vst ')\nplt.plot( times,V_1, label='forced voltage clamp')\n#plt.plot( times,V_2,label='threshold increase')\nplt.xlabel('fr')\nplt.ylabel('Mean V')\nplt.legend(loc='lower right') \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.0\n0.0\n0.0\n50.02501250625312\n70.03501750875436\n90.04502251125562\n105.05252626313155\n120.06003001500748\n140.07003501750873\n155.0775387693847\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<matplotlib.legend.Legend at 0x11ce453a0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-7-output-3.png){width=593 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-7-output-4.png){width=617 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-7-output-5.png){width=617 height=470}\n:::\n\n::: {.cell-output .cell-output-display}\n![](cns_files/figure-html/cell-7-output-6.png){width=625 height=470}\n:::\n:::\n\n\n",
    "supporting": [
      "cns_files"
    ],
    "filters": [],
    "includes": {}
  }
}